/*
 * Copyright (c)  2015-2016, Artyom Drozdov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package com.github.artyomcool.dante.core.dao;

import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteStatement;
import com.github.artyomcool.dante.annotation.CompoundIndexes;
import com.github.artyomcool.dante.annotation.DbQueries;
import com.github.artyomcool.dante.annotation.Index;
import com.github.artyomcool.dante.core.CompoundIndex;
import com.github.artyomcool.dante.core.EntityInfo;
import com.github.artyomcool.dante.core.Property;
import com.github.artyomcool.dante.core.cashe.Cache;
import com.github.artyomcool.dante.core.query.*;
import net.jcip.annotations.NotThreadSafe;

import javax.annotation.Nullable;
import java.util.List;
import java.util.concurrent.Callable;

import static com.github.artyomcool.dante.core.query.DbQueriesBase.allColumns;

/**
 * Base class for all DAO. In most cases should be accessed through {@link DaoMaster#dao(Class)} with entity class.
 * Usable for inserting, updating and deleting entities. In most cases shouldn't be used for direct queries.
 * Use {@link DaoMaster#queries(Class)} for that.
 *
 * @param <E> entity class
 */
@SuppressWarnings("unused")
@NotThreadSafe
public abstract class Dao<E> {

    @SuppressWarnings("rawTypes")
    private static final Cache NO_CACHE = new Cache() {
        @Override
        public Object get(Row row, int columnIndex) {
            return null;
        }

        @Override
        public void put(Object entity) {
        }

        @Override
        public void remove(Object entity) {
        }

        @Override
        public void clear() {
        }
    };
    private final SQLiteDatabase db;
    private final int sinceVersion;
    private final EntityInfo<E> entityInfo;
    private final Cache<E> cache;
    @Nullable
    private SQLiteStatement insertStatement = null;
    @Nullable
    private SQLiteStatement updateStatement = null;
    @Nullable
    private SQLiteStatement deleteByIdStatement = null;
    @Nullable
    private QueryImpl<E> selectAllQuery = null;

    protected Dao(SQLiteDatabase db, EntityInfo<E> entityInfo, int sinceVersion) {
        this.db = db;
        this.entityInfo = entityInfo;
        this.sinceVersion = sinceVersion;
        this.cache = notNull(entityInfo.getCache());
    }

    @SuppressWarnings("unchecked")
    private static <E> Cache<E> notNull(@Nullable Cache<E> entityInfo) {
        return entityInfo == null ? NO_CACHE : entityInfo;
    }

    /**
     * Returns a table name for this DAO.
     *
     * @return table name
     */
    public abstract String getTableName();

    /**
     * Returns a list of compound indexes of this DAO.
     * Supposed to be used for accessing {@link CompoundIndexes} annotations content.
     *
     * @return compound indexes
     */
    protected abstract List<CompoundIndex> getCompoundIndexes();

    /**
     * Binds fields to the statement.
     * @param entity entity to be bound
     * @param statement statement to bind entity's fields
     */
    protected abstract void bind(E entity, SQLiteStatement statement);

    /**
     * Binds entity's id to the statement at the specified index.
     * @param entity entity with id
     * @param statement statement to bind id
     * @param index index to be bound at
     */
    protected abstract void bindId(E entity, SQLiteStatement statement, int index);

    /**
     * Updates autogenerated id after executing insert statement.
     * @param entity inserted entity
     * @param rowId generated id
     */
    protected abstract void updateRowId(E entity, long rowId);

    /**
     * Returns DB version in which this field where presented. Used for automatic migration.
     *
     * @return DB version since field exists
     */
    public int getSinceVersion() {
        return sinceVersion;
    }

    /**
     * Returns {@link EntityInfo} of this dao.
     * In most cases there is no need to call it directly outside of generated code.
     *
     * @return EntityInfo of this dao
     */
    public EntityInfo<E> getEntityInfo() {
        return entityInfo;
    }

    /**
     * Returns all entities in DB.
     *
     * @return all entities
     * @see DbQueries
     */
    public List<E> selectAll() {
        return ensureSelectAllQuery().queryList(null);
    }

    /**
     * Inserts entity into DB. If id is autogenerated, it will be assigned.
     *
     * @param entity entity to insert
     */
    public void insert(E entity) {
        SQLiteStatement insertStatement = ensureInsertQuery();

        executeInsert(entity, insertStatement);
    }

    /**
     * Inserts entities into DB. If there is no current transaction, it will be created for batch insertion.
     * If there is one, it will be used.
     *
     * @param elements entities to insert
     */
    public void insert(Iterable<E> elements) {
        SQLiteStatement insertStatement = ensureInsertQuery();

        boolean needTransaction = !db.inTransaction();
        if (needTransaction) {
            db.beginTransaction();
        }
        try {
            for (E e : elements) {
                executeInsert(e, insertStatement);
            }
            if (needTransaction) {
                db.setTransactionSuccessful();
            }
        } finally {
            if (needTransaction) {
                db.endTransaction();
            }
        }
    }

    /**
     * Updates entity in DB. If it is not inserted into DB, method will do nothing. More precisely: update will be
     * executed, but no entities in DB will be matched for WHERE clause, so it will be nothing to update.
     *
     * @param element element to update
     */
    public void update(E element) {
        SQLiteStatement updateStatement = ensureUpdateQuery();

        executeUpdate(element, updateStatement);
    }

    /**
     * Updates entities in DB. If there is no current transaction, it will be created for batch update.
     * If there is one, it will be used.
     *
     * @param elements entities to update
     */
    public void update(Iterable<E> elements) {
        SQLiteStatement updateStatement = ensureUpdateQuery();

        boolean needTransaction = !db.inTransaction();
        if (needTransaction) {
            db.beginTransaction();
        }
        try {
            for (E e : elements) {
                executeUpdate(e, updateStatement);
            }
            if (needTransaction) {
                db.setTransactionSuccessful();
            }
        } finally {
            if (needTransaction) {
                db.endTransaction();
            }
        }
    }

    /**
     * Deletes entity from DB (and from cache as well).
     *
     * @param entity entity to delete
     */
    public void delete(E entity) {
        SQLiteStatement sqLiteStatement = ensureDeleteQuery();
        bindId(entity, sqLiteStatement, 1);
        sqLiteStatement.execute();
        cache.remove(entity);
    }

    /**
     * Deletes entities from DB. If there is no current transaction, it will be created for batch delete.
     * If there is one, it will be used.
     *
     * @param entities entities to delete
     */
    public void delete(Iterable<E> entities) {
        SQLiteStatement deleteStatement = ensureDeleteQuery();

        boolean needTransaction = !db.inTransaction();
        if (needTransaction) {
            db.beginTransaction();
        }

        try {
            for (E e : entities) {
                executeDelete(e, deleteStatement);
            }
            if (needTransaction) {
                db.setTransactionSuccessful();
            }
        } finally {
            if (needTransaction) {
                db.endTransaction();
            }
        }
    }

    /**
     * Drops all entities from DB (and cache as well).
     */
    public void clear() {
        db.execSQL("DELETE FROM \"" + getTableName() + "\"");
        cache.clear();
    }

    /**
     * Executes runnable inside a transaction.
     *
     * @param runnable runnable to execute
     */
    public void runInTx(Runnable runnable) {
        db.beginTransaction();
        try {
            runnable.run();
            db.setTransactionSuccessful();
        } finally {
            db.endTransaction();
        }
    }

    /**
     * Executes callable inside a transaction and returns it's result.
     *
     * @param callable callable to execute
     * @param <T>      result type
     * @return result provided by {@link Callable#call()}
     * @throws Exception propagated exception from {@link Callable#call()}
     */
    public <T> T callInTx(Callable<T> callable) throws Exception {
        db.beginTransaction();
        try {
            T result = callable.call();

            db.setTransactionSuccessful();
            return result;
        } finally {
            db.endTransaction();
        }
    }

    /**
     * Creates a table for this DAO. Will fail if table already exists. Columns for all properties will be created.
     * All indexes will be created if it is not exists.
     * Designed to be used in {@link DaoMaster#onCreate()}.
     *
     * @see {@link #ensureTable(int)}
     */
    public void createTable() {
        db.execSQL(createTable(false, Integer.MAX_VALUE));
        ensureIndexes(Integer.MAX_VALUE);
    }

    /**
     * Drops a table of this DAO if it exists. Associated indexes will be dropped automatically by the SQLite engine.
     */
    public void dropTable() {
        db.execSQL(dropTable(true));
    }

    /**
     * Creates a table for this DAO if it is not exists.
     * Only columns for properties with version less or equal <b>version</b> will be created.
     * Only indexes with version less or equal <b>version</b> will be created.
     * Designed to be used during migrations.
     *
     * @param version version of DB for properties and indexes (use {@link Integer#MAX_VALUE} to create all of them)
     */
    public void ensureTable(int version) {
        db.execSQL(createTable(true, version));
        ensureIndexes(version);
    }

    /**
     * Adds column for the property into the table. Will fail if column already exists.
     *
     * @param property property for adding a column
     */
    //TODO consider adding ifNotExists param
    public void addProperty(Property property) {
        String defaultValue = property.getDefaultValue() == null ? "" : " DEFAULT " + property.getDefaultValue();
        db.execSQL("ALTER TABLE \"" + getTableName() + "\" " +
                "ADD COLUMN " + property.getColumnName() + " " + property.getColumnType() +
                " " + property.getColumnExtraDefinition() + defaultValue);
    }

    /**
     * Creates index for property if it is not exists. <b>NOTE:</b> it is supposed that property is annotated with
     * an {@link Index} annotation.
     *
     * @param property property to create an index for
     */
    public void ensureIndex(Property property) {
        db.execSQL(
                "CREATE" + (property.isIndexUnique() ? " UNIQUE" : "")
                        + " INDEX IF NOT EXISTS " + property.getIndexName() + " ON " +
                        getTableName() + " (" + property.getColumnName() + ")"
        );
    }

    /**
     * Creates compound index if it is not exists.
     *
     * @param index index to create
     */
    public void ensureIndex(CompoundIndex index) {
        StringBuilder tmp = new StringBuilder();
        tmp.append("CREATE");
        if (index.isUnique()) {
            tmp.append(" UNIQUE");
        }
        tmp.append(" INDEX IF NOT EXISTS ")
                .append(index.getName())
                .append(" ON ")
                .append(getTableName())
                .append(" (");

        for (CompoundIndex.Field field : index.getFields()) {
            String columnName = field.getProperty().getColumnName();
            tmp.append(columnName);
            if (field.isDesc()) {
                tmp.append(" DESC");
            }
            tmp.append(",");
        }
        tmp.setLength(tmp.length() - 1);
        tmp.append(")");

        db.execSQL(tmp.toString());
    }

    private void executeInsert(E entity, SQLiteStatement insertStatement) {
        bind(entity, insertStatement);
        long id = insertStatement.executeInsert();
        updateRowId(entity, id);
        cache.put(entity);
    }

    private void executeUpdate(E element, SQLiteStatement updateStatement) {
        bind(element, updateStatement);
        bindId(element, updateStatement, entityInfo.getProperties().size() + 1);
        updateStatement.execute();
    }

    private void executeDelete(E entity, SQLiteStatement deleteStatement) {
        bindId(entity, deleteStatement, 1);
        deleteStatement.execute();
        cache.remove(entity);
    }

    private SQLiteStatement ensureInsertQuery() {
        if (insertStatement == null) {
            StringBuilder tmp = new StringBuilder();

            tmp.append("INSERT INTO \"")
                    .append(getTableName())
                    .append("\" (");

            allColumns(entityInfo, tmp);

            tmp.append(") VALUES (");

            int size = entityInfo.getProperties().size();
            for (int i = 1; i < size; i++) {
                tmp.append("?,");
            }
            tmp.append("?)");

            insertStatement = db.compileStatement(tmp.toString());
        }
        return insertStatement;
    }

    private SQLiteStatement ensureUpdateQuery() {
        if (updateStatement == null) {
            StringBuilder tmp = new StringBuilder();
            tmp.append("UPDATE \"")
                    .append(getTableName())
                    .append("\" SET ");

            for (Property property : entityInfo.getProperties()) {
                tmp.append(property.getColumnName()).append(" = ?").append(',');
            }

            tmp.setLength(tmp.length() - 1);

            tmp.append(" WHERE ")
                    .append(entityInfo.getIdProperty().getColumnName())
                    .append(" = ?");

            updateStatement = db.compileStatement(tmp.toString());
        }
        return updateStatement;
    }

    private SQLiteStatement ensureDeleteQuery() {
        if (deleteByIdStatement == null) {
            String tmp = "DELETE FROM \"" + getTableName() + "\" WHERE " +
                    entityInfo.getIdProperty().getColumnName() + " = ?";

            deleteByIdStatement = db.compileStatement(tmp);
        }
        return deleteByIdStatement;
    }

    private QueryImpl<E> ensureSelectAllQuery() {
        if (selectAllQuery == null) {
            StringBuilder tmp = new StringBuilder();
            tmp.append("SELECT ");

            allColumns(entityInfo, tmp);

            tmp.append(" FROM \"")
                    .append(getTableName())
                    .append("\"");

            RowReader<E> rowReader = entityInfo.getCachedOrSimpleRowReader();
            EntityIteratorFactory<E> factory = new SQLiteStringQueryEntityIteratorFactory<>(db, rowReader, tmp.toString());
            selectAllQuery = new QueryImpl<>(factory);
        }
        return selectAllQuery;
    }

    private void ensureIndexes(int version) {
        for (Property property : entityInfo.getProperties()) {
            int indexedSince = property.getIndexedSince();
            if (indexedSince == Property.NO_INDEX || indexedSince > version) {
                continue;
            }
            ensureIndex(property);
        }
        for (CompoundIndex compoundIndex : getCompoundIndexes()) {
            int indexedSince = compoundIndex.getSinceVersion();
            if (indexedSince <= version) {
                ensureIndex(compoundIndex);
            }
        }
    }

    private String createTable(boolean ifNotExists, int version) {
        StringBuilder tmp = new StringBuilder();
        tmp.append("CREATE TABLE ");
        if (ifNotExists) {
            tmp.append("IF NOT EXISTS ");
        }
        tmp.append('\'').append(getTableName()).append('\'').append(" (");
        for (Property property : entityInfo.getProperties()) {
            if (property.getSinceVersion() > version) {
                continue;
            }
            tmp.append(property.getColumnName()).append(' ')
                    .append(property.getColumnType()).append(' ')
                    .append(property.getColumnExtraDefinition()).append(',');
        }
        tmp.setLength(tmp.length() - 1);
        tmp.append(')');

        return tmp.toString();
    }

    private String dropTable(boolean ifExists) {
        StringBuilder tmp = new StringBuilder();
        tmp.append("DROP TABLE ");
        if (ifExists) {
            tmp.append("IF EXISTS ");
        }
        tmp.append('\'').append(getTableName()).append('\'');
        return tmp.toString();
    }

}
